use std::fs;
use std::io::prelude::*;
use std::io::{self, BufWriter, Write};
use std::path::Path;
use std::sync::atomic::{AtomicUsize, Ordering};
use std::collections::HashSet;

use crate::ast::*;
static SCOPE: AtomicUsize = AtomicUsize::new(0);
pub struct Compiler<W: Write> {
    buf: W,
    stack: Vec<usize>,
    for_var: HashSet<String>
}

impl<W: Write> Compiler<W> {
    pub fn new(buf: W) -> Compiler<W> {
        Compiler {
            buf,
            stack: Vec::new(),
            for_var: HashSet::new()
        }
    }

    pub fn compile(&mut self, ast: Expr) -> io::Result<()> {
        // fs::remove_file(&path)?;
        // let mut stream = BufWriter::new(fs::File::create(path)?);
        self.buf.write(b"@echo off\n")?;
        self.buf
            .write(b"REM AUTO-GENERATED FILE. DO NOT MODIFY.\n")?;
        self.buf
            .write(b"REM This file was automatically generated by the ski compiler.\n")?;

        self.compile_expr(ast)?;

        Ok(())
    }

    pub fn compile_func_call(&mut self, ast: Box<FuncCall>) -> io::Result<()> {
        match ast.func_name.as_str() {
            "range" => self.compile_range(ast.params)?,
            "print" => self.compile_echo(ast.params)?,
            _ => self.compile_func_calll(ast)?
        }
        Ok(())
    }

    pub fn compile_func_calll(&mut self, ast: Box<FuncCall>) -> io::Result<()> {
        write!(self.buf, "CALL :{} ", ast.func_name)?;
        self.compile_params(ast.params)?;
        Ok(())
    }

    pub fn compile_if(&mut self, ast: Box<If>) -> io::Result<()> {
        let mut was_logical = false;
        match &ast.cond {
            Expr::Binary(i) => match i.op {
              BinaryOpKind::BinaryAnd | BinaryOpKind::BinaryOr => {
                  was_logical = true;
                  self.compile_binary_and(i)?},
              _ => {
                  dbg!(&ast.cond);
                self.buf.write(b"IF ")?;
                self.compile_expr(ast.cond)?;
                self.buf.write(b" (\n")?;
            }
            }
            _ => {}    
          }
        self.compile_expr(ast.then)?;
        self.buf.write(b")")?;
        if was_logical {
            self.buf.write(b")")?;
        }
        if ast.else_ != Expr::Block(Vec::new()) {
            self.buf.write(b"ELSE (")?;
            self.compile_expr(ast.else_)?;
            self.buf.write(b"\n) ")?;
        } else {
            self.buf.write(b"\n")?;
        }
        Ok(())
    }

    pub fn compile_range(&mut self, mut ast: Vec<Expr>) -> io::Result<()> {
        self.buf.write(b"(")?;
        let p = ast.pop();
        for x in ast {
            self.compile_expr(x)?;
            self.buf.write(b",")?;
        }
        self.compile_expr(p.unwrap())?;
        self.buf.write(b")")?;
        Ok(())
    }

    pub fn compile_echo(&mut self, ast: Vec<Expr>) -> io::Result<()> {
        self.buf.write(b"ECHO ")?;
        self.compile_block(ast)?;
        self.buf.write(b"\n")?;
        Ok(())
    }

    pub fn compile_binary_and(&mut self, ast: &BinaryExpr) -> io::Result<()> {
        self.buf.write(b"IF ")?;
        self.compile_expr(ast.left.clone())?;
        self.buf.write(b" (\n")?;
        self.buf.write(b"IF ")?;
        self.compile_expr(ast.right.clone())?;
        self.buf.write(b")")?;
        self.buf.write(b")")?;
        self.buf.write(b"\n")?;
        Ok(())
    }

    pub fn compile_binary_or(&mut self, ast: Box<If>) -> io::Result<()> {
        Ok(())
    }
    pub fn compile_expr(&mut self, ast: Expr) -> io::Result<()> {
        match ast {
            Expr::Binary(i) => self.compile_binary_expr(i)?,
            Expr::Variable(i) => self.compile_variable(i)?,
            Expr::Int(i) => write!(self.buf, "{}", i)?,
            Expr::VariableDecl(i) => self.compile_var_decl(i)?,
            Expr::Block(i) => self.compile_block(i)?,
            Expr::For(i) => self.compile_for(i)?,
            Expr::Str(i) => write!(self.buf, "{}", i)?,
            Expr::FuncDef(i) => self.compile_func_def(i)?,
            Expr::FuncCall(i) => self.compile_func_call(i)?,
            Expr::Return(i) => self.compile_return(i)?,
            Expr::Break => self.compile_break()?,
            Expr::While(i) => self.compile_while(i)?,
            Expr::Loop(i) => self.compile_loop(i)?,
            Expr::Unary(i) => self.compile_unary_expr(i)?,
            Expr::Continue => self.compile_continue()?,
            Expr::ConstDecl(i) => self.compile_const_decl(i)?,
            Expr::If(i) => self.compile_if(i)?,
            Expr::Paren(i) => self.compile_expr(*i)?
        }
        Ok(())
    }
    pub fn compile_unary_expr(&mut self, ast: Box<UnaryExpr>) -> io::Result<()> {
        self.compile_unary_op_kind(ast.op)?;
        self.compile_expr(ast.child)?;
        Ok(())
    }
    pub fn compile_binary_expr(&mut self, ast: Box<BinaryExpr>) -> io::Result<()> {
        self.compile_expr(ast.left)?;
        self.compile_binary_op_kind(ast.op)?;
        self.compile_expr(ast.right)?;
        Ok(())
    }

    pub fn compile_for(&mut self, ast: Box<For>) -> io::Result<()> {
        self.stack.push(SCOPE.fetch_add(1, Ordering::Relaxed));
        self.for_var.insert(ast.item.clone());
        self.buf.write(b"FOR /l %%")?;
        self.buf.write(ast.item.as_bytes())?;
        self.buf.write(b" IN ")?;
        self.compile_expr(ast.container)?;
        self.buf.write(b" DO (\n")?;
        self.compile_expr(ast.body)?;
        self.buf.write(b")\n")?;
        let popped = self.stack.pop().unwrap();
        writeln!(self.buf, ":END{}", popped)?;
        self.for_var.remove(&ast.item);
        Ok(())
    }

    pub fn check_op(&mut self, ast: &Box<BinaryExpr>) -> &'static str {
        match ast.op {
            BinaryOpKind::BinaryAnd => "&&",
            BinaryOpKind::BinaryOr =>  "||",
            _ => ""
        }
    }
    pub fn compile_func_def(&mut self, ast: Box<FuncDef>) -> io::Result<()> {
        self.buf.write(b":")?;
        self.buf.write(ast.name.as_bytes())?;
        self.buf.write(b" ")?;
        if !ast.params.is_empty() {
            self.compile_params_decl(ast.params)?;
        }
        self.buf.write(b"\n")?;
        self.compile_expr(ast.body)?;
        self.buf.write(b"\n")?;
        self.buf.write(b"EXIT /B 0")?;
        Ok(())
    }

    pub fn compile_variable(&mut self, ast: String) -> io::Result<()> {
        let t = match self.for_var.get(&ast) {
            Some(v) => format!("%%{}", v),
            None => format!("%{}%", ast)
        };
        write!(self.buf, "{}", t)?;
        Ok(())
    }

    pub fn compile_params_decl(&mut self, mut ast: Vec<String>) -> io::Result<()> {
        let p = ast.pop();
        for x in ast {
            self.buf.write(x.as_bytes())?;
            self.buf.write(b", ")?;
        }
        let inside = p.unwrap();
        self.buf.write(inside.as_bytes())?;
        Ok(())
    }

    pub fn compile_params(&mut self, mut ast: Vec<Expr>) -> io::Result<()> { 
        let p = ast.pop();
        for x in ast {
            self.compile_expr(x)?;
            self.buf.write(b", ")?;
        }
        self.compile_expr(p.unwrap())?;
        Ok(())
    }

    pub fn compile_return(&mut self, ast: Box<Expr>) -> io::Result<()> {
        self.buf.write(b"SET %~1=")?;
        self.compile_expr(*ast)?;
        Ok(())
    }

    pub fn compile_break(&mut self) -> io::Result<()> {
        let popped = self.stack.pop().unwrap();
        self.stack.push(popped);
        writeln!(self.buf, "GOTO :END{}", popped)?;
        Ok(())
    }

    pub fn compile_continue(&mut self) -> io::Result<()> {
        unimplemented!();
        Ok(())
    }

    pub fn compile_const_decl(&mut self, ast: Box<ConstDecl>) -> io::Result<()> {
        unimplemented!();
        Ok(())
    }
    pub fn compile_var_decl(&mut self, ast: Box<VariableDecl>) -> io::Result<()> {
        self.buf.write(b"SET ")?;
        if ast.is_numeric {
            self.buf.write(b"/A ")?;
        }
        self.buf.write(ast.name.as_bytes())?;
        self.buf.write(b"=")?;
        self.compile_expr(ast.value)?;
        self.buf.write(b"\n")?;
        Ok(())
    }

    pub fn compile_block(&mut self, ast: Vec<Expr>) -> io::Result<()> {
        for x in ast {
            self.compile_expr(x)?;
        }
        Ok(())
    }

    pub fn compile_while(&mut self, ast: Box<While>) -> io::Result<()> {
        let num = SCOPE.fetch_add(1, Ordering::Relaxed);
        self.stack.push(num);
        write!(self.buf, ":START{}\nIF ", num)?;
        self.compile_expr(ast.cond)?;
        self.buf.write(b" (\n")?;
        self.compile_expr(ast.body)?;
        let popped = self.stack.pop().unwrap();
        writeln!(self.buf, "GOTO :START{}", popped)?;
        self.buf.write(b"\n)\n")?;
        writeln!(self.buf, ":END{}", popped)?;
        Ok(())
    }

    pub fn compile_loop(&mut self, ast: Box<Loop>) -> io::Result<()> {
        let num = SCOPE.fetch_add(1, Ordering::Relaxed);
        self.stack.push(num);
        writeln!(self.buf, ":START{}", num)?;
        self.compile_expr(ast.body)?;
        let popped = self.stack.pop().unwrap();
        writeln!(self.buf, "GOTO :START{}", popped)?;
        writeln!(self.buf, ":END{}", popped)?;
        Ok(())
    } 

    pub fn compile_binary_op_kind(&mut self, ast: BinaryOpKind) -> io::Result<()> {
        self.buf.write(match ast {
            BinaryOpKind::Add => b"+",
            BinaryOpKind::Sub => b"-",
            BinaryOpKind::Mul => b"*",
            BinaryOpKind::Div => b"/",
            BinaryOpKind::Assign => b"=",
            BinaryOpKind::Eq => b" EQU ",
            BinaryOpKind::Ne => b" NEQ ",
            BinaryOpKind::Gt => b" GTR ",
            BinaryOpKind::Lt => b" LSS ",
            BinaryOpKind::GtEq => b" GEQ ",
            BinaryOpKind::LtEq => b" LEQ ",
            BinaryOpKind::Shr => b">>",
            BinaryOpKind::Shl => b"<<",
            BinaryOpKind::Xor => b"^",
            BinaryOpKind::LogicalAnd => b"AND",
            BinaryOpKind::LogicalOr => b"OR",
            BinaryOpKind::BinaryAnd => b"&",
            BinaryOpKind::BinaryOr => b"|",
        })?;
        Ok(())
    }
    pub fn compile_unary_op_kind(&mut self, ast: UnaryOpKind) -> io::Result<()> {
        self.buf.write(match ast {
            UnaryOpKind::Minus => b"-",
            UnaryOpKind::LogicalNot => b"NOT",
            UnaryOpKind::BitwiseNot => b"~",
        })?;
        Ok(())
    }
}
